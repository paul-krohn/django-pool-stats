diff --git a/bracket.py b/bracket.py
new file mode 100755
index 0000000..8e18707
--- /dev/null
+++ b/bracket.py
@@ -0,0 +1,300 @@
+#!/usr/bin/env python
+
+import argparse
+import json
+from copy import deepcopy
+from math import log
+
+BRACKET_TYPES = ['single', 'double']  # [0] is the default
+
+parser = argparse.ArgumentParser(description='Set up a bracket.')
+parser.add_argument(
+    '--size',
+    type=int,
+    help='number of participants in the bracket',
+    # required=True,
+)
+parser.add_argument(
+    '--type',
+    help='bracket type; default: %(default)s',
+    default=BRACKET_TYPES[0],
+    choices=BRACKET_TYPES,
+)
+parser.add_argument(
+    '--team-file',
+    help='file with one team per line',
+    default=None
+)
+
+args = parser.parse_args()
+
+# double elimination winners/single elimination bracket
+
+match_rounds = []
+
+
+def bracket_size(participant_count):
+    # the guess is either the correct power of 2, ot 1 less than the correct power of 2
+    # if the participant count is equal to 2 ** guess, we are don't need to add 1 to the guess
+    guess = int(log(participant_count, 2))
+    return 2 ** (guess + int(participant_count != 2 ** guess))
+
+
+class Match(object):
+
+    def __init__(self, source_match_a, source_match_b, team_a, team_b, number, a_want_winner=True, b_want_winner=True):
+        self.source_match_a = source_match_a
+        self.source_match_b = source_match_b
+        self.team_a = team_a
+        self.team_b = team_b
+        self.winner = None
+        self.number = number
+        self.a_want_winner = a_want_winner
+        self.b_want_winner = b_want_winner
+        self.play_order = 0
+
+    def teams_desc(self, side, want):
+        if self.team_a and self.team_b:
+            description = "{} of {} vs {}".format("winner" if want else "loser", self.team_a, self.team_b)
+        else:
+            description = "{}".format(self.team_a or self.team_b)
+
+        src_m = getattr(self, 'source_match_{}'.format(side), None)
+        if src_m is not None:
+            description = "{} of match {}".format("winner" if want else "loser", self.play_order)
+        return description
+
+    def __repr__(self):
+
+        return("match {}: {} vs {}".format(
+            self.play_order,
+            'bye' if self.team_a is False else self.team_a or self.source_match_a.description('a', self.a_want_winner),
+            'bye' if self.team_b is False else self.team_b or self.source_match_b.description('b', self.b_want_winner),
+        ))
+
+
+teams = []
+if args.team_file is not None:
+    teams = json.load(open(args.team_file))['teams']
+    # print(json.dumps(teams, indent=2))
+
+
+if len(teams):
+    br_size = bracket_size(len(teams))
+else:
+    br_size = bracket_size(args.size)
+
+# print("the bracket size is: {}".format(bracket_size(br_size)))
+
+# round 1 matches
+i = 0
+first_round_matches = []
+while i < (br_size / 2):
+    if len(teams):
+        team_one = teams[i]
+        team_two = teams[(br_size - 1) - i] if len(teams) > (br_size - 1) - i else False
+    else:
+        team_one = 'Team {}'.format(i + 1)
+        team_two = 'Team {}'.format(br_size - i)
+    first_round_matches.append(
+        Match(
+            source_match_a=None,
+            source_match_b=None,
+            team_a=team_one,
+            team_b=team_two,
+            number=i + 1,
+        )
+    )
+    i += 1
+
+running_match_count = i
+match_rounds.append(first_round_matches)
+
+
+def new_round_matches(existing_round_matches, offset, winners=True, outside_in=True):
+    these_matches = []
+    inc = 0
+    size = len(existing_round_matches)
+    while inc < size / 2:
+        if outside_in:
+            this_source_match_a = existing_round_matches[inc]
+            this_source_match_b = existing_round_matches[size - inc - 1]
+        else:
+            this_source_match_a = existing_round_matches[2 * inc - size]
+            this_source_match_b = existing_round_matches[2 * inc - size + 1]
+        these_matches.append(
+            Match(
+                source_match_a=this_source_match_a,
+                source_match_b=this_source_match_b,
+                team_a=None,
+                team_b=None,
+                number=offset + inc + 1,
+                a_want_winner=winners,
+                b_want_winner=winners,
+            )
+        )
+        inc += 1
+    return these_matches
+
+
+def losers_bracket_matches(winners_round_matches, losers_round_matches, offset, reverse=False):
+    new_matches = []
+    inc = 0
+    size = len(winners_round_matches)
+    while inc < size:
+        # print("adding losers bracket match: {}".format(offset + inc + 1))
+        this_source_match_a = winners_round_matches[size - 1 - inc] if reverse else winners_round_matches[inc]
+        this_source_match_b = losers_round_matches[inc]
+        new_matches.append(
+            Match(
+                source_match_a=this_source_match_a,
+                source_match_b=this_source_match_b,
+                team_a=None,
+                team_b=None,
+                number=offset + size - inc if reverse else offset + inc + 1,
+                a_want_winner=False,
+                b_want_winner=True,
+            )
+        )
+        inc += 1
+    return new_matches
+
+
+round_count = int(log(br_size, 2))  # + (2 if args.type == 'double' else 0)
+
+prev_round_matches = first_round_matches
+losers_bracket_rounds = []
+
+while len(match_rounds) < round_count:
+    # loser's bracket initial round
+    # print("currently have {} rounds".format(len(match_rounds)))
+
+    this_round_match_objects = new_round_matches(
+        deepcopy(prev_round_matches), running_match_count
+    )
+    running_match_count += len(this_round_match_objects)
+    match_rounds.append(this_round_match_objects)
+    prev_round_matches = this_round_match_objects
+
+if args.type == 'double':
+
+    # there are log(n, 2) + (log(n, 2) / 2) rounds in the losers bracket
+    losers_bracket_round_count = round_count + round_count / 2
+    # first, seed the losers bracket
+    losers_bracket_rounds.append(new_round_matches(
+            existing_round_matches=match_rounds[0],
+            offset=running_match_count,
+            winners=False,
+        )
+    )
+    running_match_count += len(losers_bracket_rounds[-1])
+
+    # while len(losers_bracket_rounds) < losers_bracket_round_count:
+    for match_round in match_rounds[1:-1]:
+        # losers_bracket_new_matches = []
+        # reverse_it = True if (len(losers_bracket_rounds) + 1) % 4 != 0 else False
+        losers_bracket_dropin_matches = losers_bracket_matches(
+            winners_round_matches=match_round,
+            losers_round_matches=losers_bracket_rounds[-1],
+            offset=running_match_count,
+            reverse=True,
+        )
+        losers_bracket_rounds.append(losers_bracket_dropin_matches)
+        running_match_count += len(losers_bracket_dropin_matches)
+        # in this case, we want a regular elimination bracket from the previous round of the losers bracket
+        losers_bracket_elimination_matches = new_round_matches(
+            existing_round_matches=losers_bracket_rounds[-1],
+            offset=running_match_count,
+            outside_in=False,
+        )
+
+        running_match_count += len(losers_bracket_elimination_matches)
+        losers_bracket_rounds.append(losers_bracket_elimination_matches)
+    # one more losers bracket round; this one between the winner of the losers bracket and the loser of the last match
+    # of the winners
+    losers_bracket_last_round = losers_bracket_matches(
+        winners_round_matches=match_rounds[-1],
+        losers_round_matches=losers_bracket_rounds[-1],
+        offset=running_match_count,
+    )
+    losers_bracket_rounds.append(losers_bracket_last_round)
+    running_match_count += len(losers_bracket_last_round)
+
+    # now the winners vs losers match
+    bracket_joining_match = Match(
+        source_match_a=match_rounds[-1][0],
+        source_match_b=losers_bracket_last_round[0],
+        team_a=None,
+        team_b=None,
+        number=running_match_count + 1,
+    )
+    match_rounds.append([bracket_joining_match])
+    running_match_count += 1
+    # and the "if-necessary" match
+    if_necessary_match = Match(
+        source_match_a=bracket_joining_match,
+        source_match_b=bracket_joining_match,
+        team_a=None,
+        team_b=None,
+        number=running_match_count + 1,
+        a_want_winner=False,
+    )
+    match_rounds.append([if_necessary_match])
+
+# now set the play order ...
+all_matches = []
+# first the first round from each of the brackets
+play_order_inc = 1
+for match in match_rounds[0] + (losers_bracket_rounds[0] if len(losers_bracket_rounds) else []):
+    match.play_order = play_order_inc
+    all_matches.append(match)
+    play_order_inc += 1
+
+round_inc = 1
+while round_inc < round_count:
+    print("working on round {}".format(round_inc))
+    for match in match_rounds[round_inc]:
+        match.play_order = play_order_inc
+        print("set order for match {} to {}".format(match.number, match.play_order))
+        all_matches.append(match)
+        play_order_inc += 1
+    for losers_bracket_match in \
+            losers_bracket_rounds[2 * round_inc - 1] + \
+            losers_bracket_rounds[2 * round_inc] if len(losers_bracket_rounds) > 2 * round_inc else []:
+        losers_bracket_match.play_order = play_order_inc
+        all_matches.append(losers_bracket_match)
+        play_order_inc += 1
+    round_inc += 1
+
+# now add and order the matches that are on the winners and losers side, but aren't in the order in the predictable way
+# print("the rounds expected not to be ordered are: %s" % [match_rounds[round_count:] + losers_bracket_rounds[-1]])
+if args.type == 'double':
+    for match in losers_bracket_rounds[-1] + match_rounds[round_count] + match_rounds[-1]:
+        match.play_order = play_order_inc
+        all_matches.append(match)
+        play_order_inc += 1
+
+# print("match rounds: %s losers rounds: %s" % (len(match_rounds), len(losers_bracket_rounds)))
+
+# i = 0
+# for match_round in match_rounds:
+#     print("winners round %d" % (i + 1))
+#     for match in match_round:
+#         # print(" %s: %s" % (match, match.play_order or match.number))
+#         print(" %s: %s" % (match, match.play_order))
+#         # print(match)
+#     i += 1
+#
+# # print("there are {} losers bracket rounds".format(len(losers_bracket_rounds)))
+# i = 0
+# for losers_bracket_round in losers_bracket_rounds:
+#     print("losers round %d" % (i + 1))
+#     for match in losers_bracket_round:
+#         # print(" %s: %s" % (match, match.play_order or match.number))
+#         print(" %s: %s" % (match, match.play_order))
+#         # print(match)
+#     i += 1
+#
+
+for match in all_matches:
+    print("{} has number {} and order {}".format(match, match.number, match.play_order))
diff --git a/pool/stats/admin.py b/pool/stats/admin.py
index 6ac9c0a..db0ef7d 100644
--- a/pool/stats/admin.py
+++ b/pool/stats/admin.py
@@ -9,6 +9,8 @@ from django.shortcuts import redirect
 
 from .models import Division, GameOrder, Match, Player, PlayPosition, WeekDivisionMatchup
 from .models import PlayerSeasonSummary, ScoreSheet, Season, Sponsor, Table, Team, Week
+from .models import Tournament, Participant
+
 from .forms import TeamForm, MatchForm
 from .utils import expire_page
 
@@ -487,6 +489,67 @@ class TableAdmin(admin.ModelAdmin):
 admin.site.register(Table, TableAdmin)
 
 
+class TournamentAdmin(admin.ModelAdmin):
+    list_filter = [SeasonFilter]
+
+
+admin.site.register(Tournament, TournamentAdmin)
+
+
+class TournamentSeasonFilter(SeasonFilter):
+    # for admin views where the object's match is via the season
+    parameter_name = 'tournament__season'
+
+    def queryset(self, request, queryset):
+        if self.value() == 'all':
+            return queryset
+        elif self.value() is None:
+            return queryset.filter(tournament__season__is_default=True)
+        else:
+            return queryset.filter(tournament__season=self.value())
+
+
+class TournamentFilter(SimpleListFilter):
+    # a custom filter that defaults to the 'default' season, instead of a 'All'
+    # cribbed/modified from https://stackoverflow.com/questions/851636/default-filter-in-django-admin
+    title = _('Tournament')
+
+    parameter_name = 'Tournament'
+
+    def lookups(self, request, model_admin):
+        # we want to return a list of tuples of the query value and display value;
+        # in this case, all the tournaments in the default season, plus 'all'
+        choices = [(tournament.id, tournament) for tournament in Tournament.objects.filter(season__is_default=True)]
+        choices.append(('all', _('All')))
+        return choices
+
+    def choices(self, cl):
+        for lookup, title in self.lookup_choices:
+            yield {
+                'selected': self.value() == lookup,
+                'query_string': cl.get_query_string({
+                    self.parameter_name: lookup,
+                }, []),
+                'display': title,
+            }
+
+    def queryset(self, request, queryset):
+        if self.value() == 'all':
+            return queryset
+        elif self.value() is None:
+            return queryset.filter(tournament__season__is_default=True)
+        else:
+            return queryset.filter(tournament=self.value())
+
+
+class ParticipantAdmin(admin.ModelAdmin):
+    list_filter = [TournamentSeasonFilter, TournamentFilter]
+    # TODO: add a participant name attribute that picks the right thing from player/team/scotch
+    list_display = ['player', 'team', 'scotch', 'tournament']
+
+
+admin.site.register(Participant, ParticipantAdmin)
+
 # TODO:
 # It would be pretty to have, in the match admin, the teams filtered by season
 # formfield_for_foreignkey seems to be the way to go?
diff --git a/pool/stats/migrations/0038_auto_20180707_1610.py b/pool/stats/migrations/0038_auto_20180707_1610.py
new file mode 100644
index 0000000..80db427
--- /dev/null
+++ b/pool/stats/migrations/0038_auto_20180707_1610.py
@@ -0,0 +1,85 @@
+# Generated by Django 2.0.3 on 2018-07-07 16:10
+
+from django.db import migrations, models
+import django.db.models.deletion
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('stats', '0037_team_captain'),
+    ]
+
+    operations = [
+        migrations.CreateModel(
+            name='Bracket',
+            fields=[
+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+                ('type', models.TextField(choices=[('w', 'Winners'), ('l', 'Losers')])),
+            ],
+        ),
+        migrations.CreateModel(
+            name='Participant',
+            fields=[
+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+                ('type', models.TextField(choices=[('team', 'Team'), ('player', 'Player'), ('scotch', 'Scotch Doubles Team')])),
+                ('player', models.ForeignKey(null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='stats.Player')),
+            ],
+        ),
+        migrations.CreateModel(
+            name='Round',
+            fields=[
+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+                ('number', models.IntegerField(null=True)),
+                ('bracket', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='stats.Bracket')),
+            ],
+        ),
+        migrations.CreateModel(
+            name='ScotchDoublesTeam',
+            fields=[
+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+                ('players', models.ManyToManyField(to='stats.Player')),
+            ],
+        ),
+        migrations.CreateModel(
+            name='Tournament',
+            fields=[
+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+                ('name', models.TextField()),
+                ('type', models.TextField(choices=[('team_playoff', 'Team Playoff'), ('scotch_doubles', 'Scotch Doubles')])),
+                ('elimination', models.TextField(choices=[('single', 'Single Elimination'), ('double', 'Double Elimination')])),
+                ('season', models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, to='stats.Season')),
+            ],
+        ),
+        migrations.CreateModel(
+            name='TournamentMatchup',
+            fields=[
+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
+                ('number', models.IntegerField()),
+                ('a_want_winner', models.BooleanField()),
+                ('b_want_winner', models.BooleanField()),
+                ('play_order', models.IntegerField()),
+                ('participant_a', models.ForeignKey(null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='participant_a', to='stats.Participant')),
+                ('participant_b', models.ForeignKey(null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='participant_b', to='stats.Participant')),
+                ('round', models.ForeignKey(on_delete=django.db.models.deletion.DO_NOTHING, to='stats.Round')),
+                ('source_match_a', models.ForeignKey(null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='match_a', to='stats.TournamentMatchup')),
+                ('source_match_b', models.ForeignKey(null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='match_b', to='stats.TournamentMatchup')),
+                ('winner', models.ForeignKey(null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='stats.Participant')),
+            ],
+        ),
+        migrations.AddField(
+            model_name='participant',
+            name='scotch',
+            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='stats.ScotchDoublesTeam'),
+        ),
+        migrations.AddField(
+            model_name='participant',
+            name='team',
+            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.DO_NOTHING, to='stats.Team'),
+        ),
+        migrations.AddField(
+            model_name='bracket',
+            name='tournament',
+            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='stats.Tournament'),
+        ),
+    ]
diff --git a/pool/stats/migrations/0039_participant_tournament.py b/pool/stats/migrations/0039_participant_tournament.py
new file mode 100644
index 0000000..4e12d9f
--- /dev/null
+++ b/pool/stats/migrations/0039_participant_tournament.py
@@ -0,0 +1,20 @@
+# Generated by Django 2.0.3 on 2018-07-07 16:21
+
+from django.db import migrations, models
+import django.db.models.deletion
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('stats', '0038_auto_20180707_1610'),
+    ]
+
+    operations = [
+        migrations.AddField(
+            model_name='participant',
+            name='tournament',
+            field=models.ForeignKey(default=None, on_delete=django.db.models.deletion.CASCADE, to='stats.Tournament'),
+            preserve_default=False,
+        ),
+    ]
diff --git a/pool/stats/migrations/0040_auto_20180707_1905.py b/pool/stats/migrations/0040_auto_20180707_1905.py
new file mode 100644
index 0000000..5a0051b
--- /dev/null
+++ b/pool/stats/migrations/0040_auto_20180707_1905.py
@@ -0,0 +1,28 @@
+# Generated by Django 2.0.3 on 2018-07-07 19:05
+
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('stats', '0039_participant_tournament'),
+    ]
+
+    operations = [
+        migrations.AlterField(
+            model_name='tournamentmatchup',
+            name='a_want_winner',
+            field=models.NullBooleanField(),
+        ),
+        migrations.AlterField(
+            model_name='tournamentmatchup',
+            name='b_want_winner',
+            field=models.NullBooleanField(),
+        ),
+        migrations.AlterField(
+            model_name='tournamentmatchup',
+            name='play_order',
+            field=models.IntegerField(null=True),
+        ),
+    ]
diff --git a/pool/stats/models/__init__.py b/pool/stats/models/__init__.py
index eaa5616..3ab964c 100644
--- a/pool/stats/models/__init__.py
+++ b/pool/stats/models/__init__.py
@@ -12,4 +12,5 @@ from .season import Season
 from .sponsor import Sponsor
 from .table import Table
 from .team import Team, AwayTeam, HomeTeam, Tie, TieBreakerResult
+from .tournament import Participant, Tournament, Bracket, Round, TournamentMatchup
 from .week import Week
diff --git a/pool/stats/models/team.py b/pool/stats/models/team.py
index 9d0f462..27cc390 100644
--- a/pool/stats/models/team.py
+++ b/pool/stats/models/team.py
@@ -1,5 +1,3 @@
-import json
-
 from django.db import models
 
 from .division import Division
@@ -7,9 +5,14 @@ from .player import Player
 from .scoresheet import ScoreSheet
 from .season import Season
 from .table import Table
+from .globals import away_home
+
 
+class ScotchDoublesTeam(models.Model):
+    players = models.ManyToManyField('Player')
 
-from .globals import away_home, logger
+    def __str__(self):
+        return ', '.join(self.players.all())
 
 
 class Team(models.Model):
diff --git a/pool/stats/models/tournament.py b/pool/stats/models/tournament.py
new file mode 100644
index 0000000..cfaad36
--- /dev/null
+++ b/pool/stats/models/tournament.py
@@ -0,0 +1,242 @@
+from django.db import models
+from math import ceil, log
+
+
+TOURNAMENT_TYPES = [
+    ('team_playoff', 'Team Playoff'),
+    ('scotch_doubles', 'Scotch Doubles'),
+]
+
+ELIMINATION_TYPES = [
+    ('single', 'Single Elimination'),
+    ('double', 'Double Elimination'),
+]
+
+BRACKET_TYPES = [
+    ('w', 'Winners'),
+    ('l', 'Losers'),
+]
+
+ROUND_TYPES = [
+    'elimination',
+    'drop_in',
+]
+
+# these do/must match the field names in Participant, below
+PARTICIPANT_TYPES = [
+    ('team', 'Team'),
+    ('player', 'Player'),
+    ('scotch', 'Scotch Doubles Team'),
+]
+
+
+class Tournament(models.Model):
+    name = models.TextField()
+    type = models.TextField(choices=TOURNAMENT_TYPES)
+    elimination = models.TextField(choices=ELIMINATION_TYPES)
+    season = models.ForeignKey('Season', on_delete=models.CASCADE, null=True)
+
+    def __str__(self):
+        return self.name
+
+    def create_brackets(self):
+        winners_bracket = Bracket(tournament=self, type='w')
+        winners_bracket.save()
+        if self.elimination is 'double':
+            losers_bracket = Bracket(tournament=self, type='l')
+            losers_bracket.save()
+
+    def round_count(self):
+        return ceil(log(len(self.participant_set.all()), 2))
+
+    def bracket_size(self):
+        return 2 ** self.round_count()
+
+    def create_rounds(self):
+        round_inc = 0
+        while round_inc < self.round_count():
+            wbr = Round(
+                bracket=self.bracket_set.get(type='w'),
+                number=round_inc + 1,
+            )
+            wbr.save()
+            round_inc += 1
+        if self.elimination == 'double':
+            losers_bracket_round_inc = 0
+            losers_bracket_round_count = 2 * (self.round_count() - 1)
+            while losers_bracket_round_inc < losers_bracket_round_count:
+                lbr, created = Round.objects.get_or_create(
+                    bracket=self.bracket_set.get(type='l'),
+                    number=losers_bracket_round_inc + 1,
+                )
+                lbr.save()
+                losers_bracket_round_inc += 1
+
+
+class Participant(models.Model):
+    type = models.TextField(choices=PARTICIPANT_TYPES)
+    tournament = models.ForeignKey(Tournament, on_delete=models.CASCADE)
+    # these field names do/must match the PARTICIPANT_TYPES list above
+    player = models.ForeignKey('Player', on_delete=models.DO_NOTHING, null=True, blank=True)
+    team = models.ForeignKey('Team', on_delete=models.DO_NOTHING, null=True, blank=True)
+    scotch = models.ForeignKey('ScotchDoublesTeam', on_delete=models.DO_NOTHING, null=True, blank=True)
+
+    def __str__(self):
+        return getattr(self, '{}'.format(self.type)).__str__()
+
+
+class Bracket(models.Model):
+    type = models.TextField(choices=BRACKET_TYPES)
+    tournament = models.ForeignKey(Tournament, on_delete=models.CASCADE)
+
+
+class Round(models.Model):
+    bracket = models.ForeignKey(Bracket, on_delete=models.CASCADE)
+    number = models.IntegerField(null=True)
+
+    def __str__(self):
+        return '{}-{}'.format(self.bracket.type, self.number)
+
+    def matchup_count(self):
+        if self.bracket.type is 'w':
+            # return log(foo, 2) - (self.number - 1)
+            return int(self.bracket.tournament.bracket_size() / 2 ** self.number)
+        else:
+            # LS round sizes from bracket of 64: 16, 16, 8, 8, 4, 4, 2, 2, 1
+            # if round number is not divisible by 2, add 1, then use that as the power of 2 for the divisor
+            return int(self.bracket.tournament.bracket_size() / (2 ** (self.number + ceil(self.number % 2))))
+
+    def create_matchups(self):
+
+        # first round winners side matchups; assumes participant_set is in the desired order
+        i = 0
+        matchup_count = self.matchup_count()
+        br_size = 2 * matchup_count
+
+        winners_side_rounds = self.bracket.tournament.bracket_set.get(type='w').round_set.all()
+        losers_side_rounds = self.bracket.tournament.bracket_set.get(type='l').round_set.all()
+
+        while i < matchup_count:
+            # source matches; not set in first round
+            sma = None
+            smb = None
+            # participants; only set in first round winner's side
+            pa = None
+            pb = None
+            # do we want winners? mostly yes; override for drop-in matches
+            wwa = True
+            wwb = True
+            if self.number == 1:
+                if self.bracket.type is 'w':
+                    pa = self.bracket.tournament.participant_set.all()[i]
+                    pb = None  # allows for byes when the bracket is not full
+                    if len(self.bracket.tournament.participant_set.all()) > (br_size - 1) - i:
+                        pb = self.bracket.tournament.participant_set.all()[(br_size - 1) - i]
+                else:
+                    # losers bracket round one is also a special case; we initialize from losers of all the
+                    # round one winners side matches
+                    # source_round = self.bracket.tournament.bracket_set.get(type__eq='w').round_set.get(number=1)
+                    source_round_matchups = winners_side_rounds.get(number=1).tournamentmatchup_set.all()
+                    sma = source_round_matchups[i]
+                    smb = source_round_matchups[br_size - i - 1]
+            else:
+                if self.bracket.type is 'w':
+                    source_round_matchups = winners_side_rounds.get(number=self.number - 1).tournamentmatchup_set.all()
+                    sma = source_round_matchups[i]
+                    smb = source_round_matchups[br_size - i - 1]
+                elif self.number % 2 == 0:
+                    # this is an "elimination" losers bracket round; source matches are the previous round
+                    source_round_matchups = losers_side_rounds.get(number=self.number - 1).tournamentmatchup_set.all()
+                    print("source round matchups: {}".format(source_round_matchups))
+                    sma = source_round_matchups[i]
+                    smb = source_round_matchups[matchup_count - i - 1]  # yikes why does this work
+                else:
+                    # this is a "drop-in" losers bracket round; we mix the losers and winners brackets
+                    winners_source_matches = winners_side_rounds.get(number=self.number - 1).tournamentmatchup_set.all()
+                    losers_source_matches = losers_side_rounds.get(number=self.number - 1).tournamentmatchup_set.all()
+                    sma = winners_source_matches[i]
+                    wwa = False
+                    smb = losers_source_matches[i]
+
+            tm, created = TournamentMatchup.objects.get_or_create(
+                source_match_a=sma,
+                source_match_b=smb,
+                participant_a=pa,
+                participant_b=pb,
+                a_want_winner=wwa,
+                b_want_winner=wwb,
+                # round=self.bracket_set.get(type=side).round_set.get(number=1),
+                round=self,
+                number=i + 1,
+            )
+            print("matchup {} vs {}:  was created: {}".format(
+                tm.participant_a, tm.participant_b, created)
+            )
+            tm.save()
+            i += 1
+
+
+class TournamentMatchup(models.Model):
+
+    round = models.ForeignKey(Round, on_delete=models.DO_NOTHING)
+    # TODO: make deleting a round delete a matchup
+    source_match_a = models.ForeignKey(
+        'stats.TournamentMatchup', on_delete=models.DO_NOTHING, null=True,
+        related_name='match_a',
+    )
+    source_match_b = models.ForeignKey(
+        'stats.TournamentMatchup', on_delete=models.DO_NOTHING, null=True,
+        related_name='match_b',
+    )
+
+    participant_a = models.ForeignKey(
+        Participant, on_delete=models.DO_NOTHING, null=True,
+        related_name='participant_a'
+    )
+    participant_b = models.ForeignKey(
+        Participant, on_delete=models.DO_NOTHING, null=True,
+        related_name='participant_b'
+    )
+
+    winner = models.ForeignKey(
+        Participant, on_delete=models.DO_NOTHING, null=True,
+    )
+
+    number = models.IntegerField()
+    a_want_winner = models.NullBooleanField(null=True)
+    b_want_winner = models.NullBooleanField(null=True)
+    play_order = models.IntegerField(null=True)
+
+    def description(self, side, want):
+        print('describing match {}'.format(self.number))
+        if self.participant_a and self.participant_b:
+            description = "{} of {} vs {}".format("winner" if want else "loser", self.participant_a, self.participant_b)
+        else:
+            description = "{}".format(self.participant_a or self.participant_b)
+
+        src_m = getattr(self, 'source_match_{}'.format(side), None)
+        if src_m is not None:
+            description = "{} of match {}".format("winner" if want else "loser", self.play_order)
+        return description
+
+    def __str__(self):
+        print('stringing match number {} in bracket {}/{} tournament {} between {} and {}'.format(
+            self.play_order, self.round.bracket, self.round.bracket.type, self.round.bracket.tournament,
+            self.participant_a, self.participant_b,
+        ))
+
+        participant_b_string = self.participant_b
+        if self.participant_b is None:
+            if self.source_match_b is not None:
+                participant_b_string = self.source_match_b.description('b', self.b_want_winner)
+            else:
+                participant_b_string = 'bye'
+
+        return ("match {}: {} vs {}".format(
+            self.play_order,
+            'bye' if self.participant_a is False else self.participant_a or
+                self.source_match_a.description('a', self.a_want_winner),
+                participant_b_string
+            )
+        )
+
diff --git a/pool/stats/templates/stats/tournament.html b/pool/stats/templates/stats/tournament.html
new file mode 100644
index 0000000..dd1c77b
--- /dev/null
+++ b/pool/stats/templates/stats/tournament.html
@@ -0,0 +1,20 @@
+{% extends "stats/base.html" %}
+{% block title %}SFPA :: Teams{% endblock %}
+
+{% block content %}
+<div class="text-center">
+<h2>{{ tournament }}</h2>
+{% for bracket in tournament.bracket_set.all %}
+    {% for round in bracket.round_set.all %}
+    <p>{{ round }}</p>
+        {% for matchup in round.tournamentmatchup_set.all %}
+            <p>
+            {% if matchup %}
+                {{ matchup }}
+            {% endif %}
+            </p>
+        {%  endfor %}
+    {%  endfor %}
+{%  endfor %}
+</div>
+{% endblock %}
\ No newline at end of file
diff --git a/pool/stats/templates/stats/tournaments.html b/pool/stats/templates/stats/tournaments.html
new file mode 100644
index 0000000..bd3906a
--- /dev/null
+++ b/pool/stats/templates/stats/tournaments.html
@@ -0,0 +1,12 @@
+{% extends "stats/base.html" %}
+{% block title %}SFPA :: Tournament {% endblock %}
+
+{% block content %}
+<div class="text-center">
+<h2>Tournaments</h2>
+{% for tournament in tournaments %}
+    <p><a href="{% url 'tournament' tournament.id %}">{{ tournament }}</a></p>
+{#            <td><!-- {{ team }} sort lexically --><a href="{% url 'team' team.id %}">{{ team }}</a></td>#}
+{%  endfor %}
+</div>
+{% endblock %}
\ No newline at end of file
diff --git a/pool/stats/urls.py b/pool/stats/urls.py
index 1720945..61b4b10 100644
--- a/pool/stats/urls.py
+++ b/pool/stats/urls.py
@@ -11,6 +11,7 @@ from .views import player
 from .views import season
 from .views import sponsor
 from .views import team
+from .views import tournament
 
 
 view_cache_time = settings.VIEW_CACHE_TIME
@@ -56,6 +57,10 @@ urlpatterns = [
     url(r'^seasons/', season.seasons, name='seasons'),
     url(r'^set_season/(?P<season_id>[0-9]+)/$', season.set_season, name='set_season'),
 
+    url(r'^tournaments/(?P<season_id>[0-9]+)', cache_page(view_cache_time)(tournament.tournaments), name='tournaments'),
+    url(r'^tournaments/', tournament.tournaments, name='tournaments'),
+    url(r'^tournament/(?P<tournament_id>[0-9]+)', tournament.tournament, name='tournament'),
+
     url(r'^update_stats/', views.update_stats, name='update_stats'),
 
     url(r'^__status', status.index),
diff --git a/pool/stats/views/tournament.py b/pool/stats/views/tournament.py
new file mode 100644
index 0000000..54bc3b9
--- /dev/null
+++ b/pool/stats/views/tournament.py
@@ -0,0 +1,27 @@
+from django.shortcuts import redirect, render, get_object_or_404
+
+from ..models import Tournament, Participant, Bracket, Round, TournamentMatchup
+
+from ..views import check_season
+
+
+def tournaments(request, season_id=None):
+    check_season(request)
+    if season_id is None:
+        return redirect('tournaments', season_id=request.session['season_id'])
+    tournament_list = Tournament.objects.filter(season=season_id)
+    context = {
+        'tournaments': tournament_list,
+    }
+    return render(request, 'stats/tournaments.html', context)
+
+
+def tournament(request, tournament_id):
+    check_season(request)
+
+    a_tournament = Tournament.objects.get(id=tournament_id)
+    context = {
+        'tournament': a_tournament,
+    }
+    return render(request, 'stats/tournament.html', context)
+
